<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Krigos' Blog</title>
    <link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/mdui/0.4.3/css/mdui.min.css">
    <script src="https://cdnjs.loli.net/ajax/libs/mdui/0.4.3/js/mdui.min.js"></script>
    <!-- <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script> -->
    <script src="https://highlightjs.org/static/highlight.site.pack.js"></script>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
        integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">
    <link rel="stylesheet" href="../style/main.css">
    <script src="../js/headroom.js"></script>
</head>

<body class="mdui-theme-accent-orange">
    <div class="mdui-appbar mdui-appbar-fixed mdui-shadow-0">
        <div class="mdui-toolbar mdui-color-theme">
            <a href="../index.html" class="mdui-typo-headline"><strong>Konjac</strong>Krigos</a>
            <div class="mdui-toolbar-spacer"></div>
            <a href="../index.html#" class="mdui-btn">home</a>
            <a href="../article.html" class="mdui-btn ">articles</a>
            <a href="../index.html#about" class="mdui-btn ">about</a>
            <a href="javascript:;" class="mdui-btn ">links</a>
            <a href="javascript:;" class="mdui-btn ">thanks</a>
        </div>
    </div>
    <div class="mdui-fab-wrapper" id="scroll-top">
        <a class="mdui-fab mdui-ripple mdui-color-blue mdui-text-color-white" href="#">
            <i class="mdui-icon material-icons">keyboard_arrow_up</i>
        </a>
    </div>
    <div id="banner">
    	<div id="banner-title" style="color:#102b6a!important;-webkit-text-stroke: 0.4px white;"><span>P1169 棋盘制作</span></div>
        <img id="banner-img" src="https://s2.ax1x.com/2019/10/04/uDqLuD.jpg">
    </div>
    <br>
    <div id="main_article">
    <h6>警告:如果世界将在一分钟内毁灭，请只阅读粗体部分</h6>
    <h6>警告:如果离世界毁灭还有两分钟，请把<i>斜体字看清楚</i></h6>
    <br>
    <h2>0.Reason 我为什么要写这个题解</h2>
    <p>因为其他人的题解我看不懂</p>
    <p><h2>1.正文</h2></p>
    <h3>1.1 选择方法</h3>
    <p>这道题是求一个符合条件的最大子矩阵，并且限制条件比较毒瘤。所以我们选择悬线法。<b>悬线法适合解决求一个限制条件较多的最大子矩阵问题。</b></p>
    <p><h3>1.2 讲（xia）解（che）</h3></p>
    <h4>1.2.1 何为悬线法</h4>
    <p>悬线的定义是这样的：</p>
    <p><b>从每一个点向上走，知道遇到障碍点或顶边界。</b></p>
    <p>那么我们可以轻松地得到悬线的一些性质：</p>
    <p><b>1. 每一个点对应一根悬线</b></p>
    <p><b>2. 每一根悬线都对应了一个高度等于悬线高度，宽度大于0的矩形</b></p>
    <p><b>所以悬线法的步骤就是：</b><b>找出每一个点对应的悬线的高度，然后向左右分别找出该悬线能拓展出的矩形的宽度。</b></p>
    <p><h4>1.2.2</h4></p>
    <p>悬线法的步骤：</p>
    <p>1.定义一个up[i][j]数组,up[i][j]表示（i，j）<i>对应的悬线</i>的长度，那么很明显：</p>
    <pre>
    <code class="cpp">
        if(check()==true)                
            up[i][j]=up[i-1][j]+1;
        else
            up[i][j]=1;
            //可能是0，根据具体题目，本题因为如果上下两个点相同时也可以取（i，j）一个点作为悬线，所以初值为1
        </code>
    </pre>
    <p>2.定义一个left[i][j]数组，表示（i,j)<i>对应的悬线</i>向左的最大宽度，同理，定义一个right数组。可以得到</p>
    <pre>
    <code class="cpp">
    if(check()==true)
        left[i][j]=max(left[i-1][j],left[i][j]),
        right[i][j]=min(right[i-1][j],right[i][j]);
        </code>
    </pre>
    <p>那么，left，right的初值就应该是（i，j）这个<i>点</i>向左的最大宽度。</p>
    <p><h4>1.2.3 为什么悬线法是正确的</h4></p>
    <p><b>木桶原理：</b>一个木桶装水的体积是由它最短木板的长度决定的。那么同理，从一个图形中找矩形也一定是由它的最短悬线确定。那么那个最大的矩形也应该是有一根悬线确定的，所以我们找到了这根悬线，我们就可以求出最大面积。而悬线与点一一对应，<b>所以只要我们枚举了所有的点，就可以保证找到确定最大矩形的悬线。</b></p>
    <p><h3>1.3 代码实现</h3></p>
    <pre>
        <code class="cpp">
    #include&lt;cstdio&gt;
    #define N 2005
    #define max(a,b) a>b?a:b
    #define min(a,b) a&lt;b?a:b
    using namespace std;
    int up[N][N],left[N][N],right[N][N],ansa,ansb,a[N][N],m,n;
    int main(){
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                up[i][j]=1,left[i][j]=j,right[i][j]=j,scanf("%d",&a[i][j]);// up 初值，读入，left/right 最初值
                
        for(int i=1;i<=n;i++)
            for(int j=2;j<=m;j++)
                if(a[i][j]^a[i][j-1])
                    left[i][j]=left[i][j-1];
        for(int i=1;i<=n;i++)
            for(int j=m;j>1;j--)
                if(a[i][j]^a[i][j-1])
                    right[i][j-1]=right[i][j];//left/right初值，即（i，j）点向左/右的最大宽度
                    
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++){
                if(i>1&&a[i][j]^a[i-1][j])
                    up[i][j]=up[i-1][j]+1,
                    left[i][j]=max(left[i][j],left[i-1][j]),right[i][j]=min(right[i][j],right[i-1][j]);
                int a=right[i][j]-left[i][j]+1;
                int b=min(a,up[i][j]);
                ansa=max(ansa,b*b);
                ansb=max(ansb,a*up[i][j]);
            }
        printf("%d\n%d",ansa,ansb);
        } 
        </code>
    </pre>
    <p> 代码中有几点值得注意</p>
    <p> 1. c++iostream中有一个left函数，所以请不要引用bits/stdc++.h或iostream</p>
    <p> 1. 求正方形的面积就是长方形较短边长的平方</p>
    <p> <h2>2.结语</h2></p>
    <p> 没有结语（逃</p>
    </div>
    <script>hljs.initHighlightingOnLoad();</script>
</body>

</html>